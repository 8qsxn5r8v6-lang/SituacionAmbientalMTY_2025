# -*- coding: utf-8 -*-
"""Analisis de los datos

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1oyTkoxsHSpdYrR9gesvezg1fvGlgnwWV
"""

!pip install pandas

import pandas as pd

df = pd.read_csv("/content/DATOS 23-24.csv")

df.info()

df.head()

import pandas as pd
# Asume que 'df' es tu DataFrame
# df = pd.DataFrame(...)

# --- PASOS ---

# 1. Obtener la Fila de Referencia (Índice 1)
fila_referencia = df.iloc[0]

# 2. Identificar y obtener los nombres de las columnas donde el valor es "CO"
#    Esto crea la lista de columnas que queremos MANTENER.
columnas_a_mantener = fila_referencia[fila_referencia == "CO"].index.tolist()

# 3. Filtrar el DataFrame, eliminando automáticamente todas las demás columnas
df_filtrado = df[columnas_a_mantener]

print("Columnas que se mantuvieron:", columnas_a_mantener)
# print(df_filtrado.head())

# 1. Verifica valores faltantes (nulos)
faltantes = df_filtrado.isnull().sum()
porcentaje_faltantes = faltantes * 100 / len(df_filtrado)
print("Valores faltantes por columna (%):")
print(porcentaje_faltantes[porcentaje_faltantes > 0])

# 2. Revisión de rangos de valores
for col in df_filtrado.columns[1:]:  # asumiendo que la primera columna es fecha/ID
    datos = pd.to_numeric(df_filtrado[col], errors='coerce')
    print(f"\nColumna: {col}")
    print(f"  Mínimo: {datos.min()}  Máximo: {datos.max()}")

    # 3. Detección de valores espurios (ejemplo para CO en ppm)
    valores_espurios = datos[(datos < 0) | (datos > 50)]  # define umbral según tu experiencia
    if len(valores_espurios) > 0:
        print(f"  Valores espurios encontrados (CO<0 o CO>50):")
        print(valores_espurios)

# 4. Revisión rápida de tipo de dato
print("\nTipos de datos por columna:")
print(df_filtrado.dtypes)

import numpy as np

# Elimina las filas de metadatos, conserva solo los datos numéricos (desde index=2)
df_limpio = df_filtrado.iloc[2:].reset_index(drop=True)

# Convierte todas las columnas relevantes a valores numéricos (excepto la primera si es fecha)
for col in df_limpio.columns[1:]:
    df_limpio[col] = pd.to_numeric(df_limpio[col], errors='coerce')

def rellenar_blancos_con_promedio(serie):
    datos = serie.copy().astype(float)
    n = len(datos)
    i = 0
    while i < n:
        if np.isnan(datos[i]):
            prev_idx = i - 1
            while prev_idx >= 0 and np.isnan(datos[prev_idx]):
                prev_idx -= 1
            prev_val = datos[prev_idx] if prev_idx >= 0 else np.nan

            nxt_idx = i + 1
            while nxt_idx < n and np.isnan(datos[nxt_idx]):
                nxt_idx += 1
            nxt_val = datos[nxt_idx] if nxt_idx < n else np.nan

            if not np.isnan(prev_val) and not np.isnan(nxt_val):
                fill_val = (prev_val + nxt_val) / 2
                for j in range(prev_idx + 1, nxt_idx):
                    datos[j] = fill_val
                i = nxt_idx
            elif not np.isnan(prev_val):
                for j in range(prev_idx + 1, min(nxt_idx, n)):
                    datos[j] = prev_val
                i = nxt_idx
            elif not np.isnan(nxt_val):
                for j in range(i, nxt_idx):
                    datos[j] = nxt_val
                i = nxt_idx
            else:
                i += 1
        else:
            i += 1
    return datos

# Imputa valores nulos en cada columna numérica
for col in df_limpio.columns[0:]:
    df_limpio[col] = rellenar_blancos_con_promedio(df_limpio[col])

print("¿Quedan nulos?")
print(df_limpio.isnull().sum())

# Deja solo los datos numéricos desde la fila 2
df_numerico = df_filtrado.iloc[2:].reset_index(drop=True)

# Convierte todas las columnas a tipo numérico si no lo has hecho
for col in df_numerico.columns:
    df_numerico[col] = pd.to_numeric(df_numerico[col], errors='coerce')

# Calcula las métricas estadisticas para todas las columnas
metricas = pd.DataFrame({
    'Máximo': df_numerico.max(),
    'Mínimo': df_numerico.min(),
    'Media': df_numerico.mean()
})
print("Métricas estadísticas (23-24):")
display(metricas)

# Supón que tu DataFrame original se llama df y el filtrado se llama df_filtrado

# Extrae la primera columna como Serie
col_fecha = df.iloc[:, 0]

# Agrega la columna de fecha a tu DataFrame filtrado si no está incluida
df_merged = df_filtrado.copy()
if col_fecha.name not in df_filtrado.columns:
    df_merged.insert(0, col_fecha.name, col_fecha)

# Si ambas DataFrames tienen igual índice, esto funcionará directamente.
# Si hay que alinear por fecha y el índice es diferente, puedes hacer:
# df_merged = pd.concat([col_fecha, df_filtrado], axis=1)

print(df_merged.head())

print(df_merged.iloc[2])